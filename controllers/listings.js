const Listing = require("../models/listing");
const fetch = require('node-fetch');

// AI Itinerary Generation with Gemini API
module.exports.generateItinerary = async (req, res) => {
    try {
        console.log('Received request body:', req.body);
        const { location, country, budget, days, preferences, listingTitle } = req.body;

        // Validate input
        if (!location || !budget || !days) {
            console.log('Validation failed - missing fields:', { location, budget, days });
            return res.status(400).json({
                success: false,
                error: 'Missing required fields'
            });
        }

        console.log('Validation passed, proceeding with itinerary generation');

        const apiKey = process.env.GEMINI_API_KEY;
        console.log('Gemini API key present:', !!apiKey);
        if (!apiKey) {
            console.log('Using fallback itinerary generation (no Gemini API key)');
            // Fallback to rule-based generation if no API key
            const itinerary = generateItineraryData(location, country, budget, days, preferences);
            return res.json({
                success: true,
                itinerary: itinerary
            });
        }

        console.log('Making Gemini API call...');

        // Create detailed prompt for Gemini
        const prompt = createItineraryPrompt(location, country, budget, days, preferences, listingTitle);

        // Call Gemini API with correct format
        const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;

        const response = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }]
            })
        });

        console.log('Gemini API response status:', response.status);
        console.log('Gemini API response ok:', response.ok);

        if (!response.ok) {
            const errorText = await response.text();
            console.log('Gemini API error response:', errorText);
            throw new Error(`Gemini API error: ${response.status}`);
        }

        const data = await response.json();
        console.log('Gemini API Response:', JSON.stringify(data, null, 2));

        const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;

        if (!generatedText) {
            console.log('No text generated by Gemini');
            throw new Error('No response from Gemini API');
        }

        console.log('Generated text:', generatedText);

        // Parse the generated itinerary
        const itinerary = parseGeminiItinerary(generatedText, days);

        res.json({
            success: true,
            itinerary: itinerary
        });

    } catch (error) {
        console.error('Itinerary generation error:', error);
        // Always fallback to rule-based generation on any error
        console.log('Falling back to rule-based generation due to error');
        const itinerary = generateItineraryData(location || 'Unknown Location', country || 'Unknown Country', budget || 'moderate', parseInt(days) || 3, preferences || []);
        res.json({
            success: true,
            itinerary: itinerary,
            fallback: true,
            error: error.message
        });
    }
};

// Create detailed prompt for Gemini
function createItineraryPrompt(location, country, budget, days, preferences, listingTitle) {
    const budgetDetails = {
        budget: "₹1,000-3,000 per day, focus on affordable activities, street food, free attractions",
        moderate: "₹3,000-8,000 per day, mix of affordable and premium experiences",
        luxury: "₹8,000+ per day, premium experiences, fine dining, private tours"
    };

    const preferenceText = preferences.length > 0
        ? `User preferences: ${preferences.join(', ')}`
        : 'No specific preferences mentioned';

    return `Create a detailed ${days}-day itinerary for a trip to ${location}, ${country}.

TRAVELER PROFILE:
- Budget: ${budget} (${budgetDetails[budget]})
- Duration: ${days} days
- ${preferenceText}
- Staying at: ${listingTitle}

REQUIREMENTS:
1. Create ${days} unique days with different themes/activities
2. Include realistic time slots (morning, afternoon, evening)
3. Suggest specific restaurants/attractions that exist in ${location}
4. Include transportation between activities
5. Provide accurate cost estimates in INR
6. Make it practical and achievable
7. Consider weather and seasonal activities if relevant

FORMAT YOUR RESPONSE AS FOLLOWS:

Day 1: [Theme/Activity Focus]
Activities:
• [Morning activity with time and description]
• [Afternoon activity with time and description]
• [Evening activity with time and description]

Dining:
• Breakfast: [Restaurant name and estimated cost]
• Lunch: [Restaurant name and estimated cost]
• Dinner: [Restaurant name and estimated cost]

Estimated Daily Cost: ₹[amount]

[Repeat for each day]

IMPORTANT:
- Use real places and restaurants that exist in ${location}
- Be specific with names and locations
- Keep activities realistic for the time available
- Consider the budget constraints
- Make it engaging and informative`;
}

// Parse Gemini response into structured itinerary
function parseGeminiItinerary(text, days) {
    const itinerary = [];
    const dayRegex = /Day (\d+): ([^\n]+)/gi;
    const activitiesRegex = /Activities:([\s\S]*?)(?=Dining:|Day \d+:|Estimated|$)/gi;
    const diningRegex = /Dining:([\s\S]*?)(?=Day \d+:|Estimated|$)/gi;
    const costRegex = /Estimated Daily Cost: ₹?([\d,]+)/gi;

    let match;
    let dayCount = 0;

    while ((match = dayRegex.exec(text)) !== null && dayCount < days) {
        const dayNum = parseInt(match[1]);
        const theme = match[2].trim();

        // Get activities for this day
        const activitiesMatch = activitiesRegex.exec(text);
        const activities = activitiesMatch
            ? activitiesMatch[1]
                .split('\n')
                .map(line => line.replace(/^[•\-*]\s*/, '').trim())
                .filter(line => line.length > 0)
            : ['Explore local attractions', 'Visit nearby markets', 'Enjoy local cuisine'];

        // Get dining for this day
        const diningMatch = diningRegex.exec(text);
        const dining = diningMatch
            ? diningMatch[1]
                .split('\n')
                .map(line => line.replace(/^[•\-*]\s*/, '').trim())
                .filter(line => line.length > 0)
            : ['Local breakfast spot', 'Nearby restaurant', 'Evening dining'];

        // Get cost
        const costRegex = /Estimated Daily Cost: ₹?([\d,]+)/gi;
        const costMatch = costRegex.exec(text);
        const estimatedCost = costMatch
            ? `₹${costMatch[1]}`
            : '₹2,000 - ₹4,000';

        itinerary.push({
            theme: theme,
            activities: activities.slice(0, 3), // Limit to 3 activities
            dining: dining.slice(0, 3), // Limit to 3 dining options
            estimatedCost: estimatedCost
        });

        dayCount++;
    }

    // If Gemini didn't provide enough days, fill with fallback
    while (itinerary.length < days) {
        itinerary.push({
            theme: `Day ${itinerary.length + 1} Exploration`,
            activities: [
                'Visit local attractions',
                'Explore nearby areas',
                'Enjoy local culture'
            ],
            dining: [
                'Local breakfast',
                'Nearby restaurant',
                'Evening dining'
            ],
            estimatedCost: '₹2,000 - ₹4,000'
        });
    }

    return itinerary;
}

// Helper function to generate itinerary data (fallback)
function generateItineraryData(location, country, budget, days, preferences) {
    const budgetMultipliers = {
        budget: 1,
        moderate: 2.5,
        luxury: 5
    };

    const baseCosts = {
        budget: { meal: 300, activity: 500, transport: 200 },
        moderate: { meal: 800, activity: 1200, transport: 400 },
        luxury: { meal: 2000, activity: 3000, transport: 800 }
    };

    const costs = baseCosts[budget];
    const multiplier = budgetMultipliers[budget];

    // Location-specific activities and attractions
    const locationData = getLocationActivities(location.toLowerCase(), country.toLowerCase());

    const itinerary = [];

    for (let day = 1; day <= days; day++) {
        const dayActivities = [];
        const dayDining = [];

        // Morning activity
        if (preferences.includes('adventure') && day % 2 === 1) {
            dayActivities.push(locationData.adventure[Math.floor(Math.random() * locationData.adventure.length)]);
        } else if (preferences.includes('culture') && day % 2 === 0) {
            dayActivities.push(locationData.culture[Math.floor(Math.random() * locationData.culture.length)]);
        } else {
            dayActivities.push(locationData.attractions[Math.floor(Math.random() * locationData.attractions.length)]);
        }

        // Afternoon activity
        if (preferences.includes('shopping') && day === Math.ceil(days/2)) {
            dayActivities.push(locationData.shopping[Math.floor(Math.random() * locationData.shopping.length)]);
        } else if (preferences.includes('relaxation')) {
            dayActivities.push(locationData.relaxation[Math.floor(Math.random() * locationData.relaxation.length)]);
        } else {
            dayActivities.push(locationData.attractions[Math.floor(Math.random() * (locationData.attractions.length - 1)) + 1]);
        }

        // Evening activity
        if (preferences.includes('nightlife') && day > 1) {
            dayActivities.push(locationData.nightlife[Math.floor(Math.random() * locationData.nightlife.length)]);
        } else if (preferences.includes('food')) {
            dayActivities.push("Explore local food scene and street food");
        }

        // Dining recommendations
        if (preferences.includes('food')) {
            dayDining.push(`Breakfast: Local café (${costs.meal}₹)`);
            dayDining.push(`Lunch: ${locationData.restaurants[Math.floor(Math.random() * locationData.restaurants.length)]} (${costs.meal * 1.5}₹)`);
            dayDining.push(`Dinner: Fine dining experience (${costs.meal * 2}₹)`);
        } else {
            dayDining.push(`Breakfast: Hotel/Listing (${costs.meal}₹)`);
            dayDining.push(`Lunch: Local restaurant (${costs.meal * 1.2}₹)`);
            dayDining.push(`Dinner: Casual dining (${costs.meal * 1.5}₹)`);
        }

        // Calculate estimated cost for the day
        const dayCost = (costs.meal * 4.7) + (costs.activity * 2) + costs.transport;
        const estimatedCost = `₹${Math.round(dayCost * multiplier)} - ₹${Math.round(dayCost * multiplier * 1.3)}`;

        // Day theme
        const themes = ["Exploration Day", "Adventure Day", "Cultural Immersion", "Relaxation Day", "Local Experience"];
        const theme = themes[day % themes.length];

        itinerary.push({
            theme: theme,
            activities: dayActivities,
            dining: dayDining,
            estimatedCost: estimatedCost
        });
    }

    return itinerary;
}

// Location-specific data
function getLocationActivities(location, country) {
    // Default data structure
    const defaultData = {
        attractions: [
            "Visit local markets and bazaars",
            "Explore historical sites",
            "Take a scenic walk",
            "Visit local museums",
            "Photography tour of landmarks"
        ],
        adventure: [
            "Hiking in nearby hills",
            "Water sports activities",
            "Mountain biking",
            "Rock climbing",
            "Wildlife safari"
        ],
        culture: [
            "Visit ancient temples",
            "Explore colonial architecture",
            "Attend local cultural shows",
            "Visit art galleries",
            "Learn traditional crafts"
        ],
        relaxation: [
            "Spa and wellness center",
            "Beach relaxation",
            "Yoga and meditation",
            "Garden visits",
            "Hot springs (if available)"
        ],
        shopping: [
            "Local handicraft markets",
            "Shopping districts",
            "Souvenir shopping",
            "Local boutiques",
            "Street shopping"
        ],
        nightlife: [
            "Live music venues",
            "Cocktail bars",
            "Cultural performances",
            "Beach parties",
            "Night markets"
        ],
        restaurants: [
            "Traditional local cuisine",
            "International fusion",
            "Street food experience",
            "Fine dining",
            "Café culture"
        ]
    };

    // Location-specific overrides
    const locationSpecific = {
        'malibu': {
            attractions: ["Malibu Pier", "Santa Monica Mountains", "Beach walks", "Surf spots", "Hollywood Hills view"],
            adventure: ["Surfing lessons", "Kayaking", "Whale watching", "Hiking trails", "Scuba diving"],
            relaxation: ["Beach yoga", "Spa treatments", "Sunset watching", "Meditation retreats"]
        },
        'new york': {
            attractions: ["Central Park", "Times Square", "Brooklyn Bridge", "Statue of Liberty", "Empire State Building"],
            culture: ["Broadway shows", "Museum of Modern Art", "Metropolitan Museum", "Cultural districts"],
            nightlife: ["Broadway shows", "Jazz clubs", "Roof-top bars", "Night tours"]
        },
        'aspen': {
            adventure: ["Skiing", "Snowboarding", "Snowshoeing", "Ice skating", "Mountain biking"],
            relaxation: ["Hot springs", "Spa treatments", "Mountain views", "Wildlife watching"]
        },
        'florence': {
            culture: ["Uffizi Gallery", "Duomo Cathedral", "Piazza della Signoria", "Boboli Gardens", "Art workshops"],
            attractions: ["Renaissance architecture", "Wine tasting", "Leather markets", "Gelato making"]
        }
    };

    // Return location-specific data if available, otherwise default
    return locationSpecific[location.toLowerCase()] || defaultData;
}

module.exports.index=async(req,res)=>{
        const { search, minPrice, maxPrice } = req.query;
        let query = {};

        if (search) {
            query.$or = [
                { title: { $regex: search, $options: 'i' } },
                { location: { $regex: search, $options: 'i' } },
                { country: { $regex: search, $options: 'i' } }
            ];
        }

        if (minPrice || maxPrice) {
            query.price = {};
            if (minPrice) query.price.$gte = parseInt(minPrice);
            if (maxPrice) query.price.$lte = parseInt(maxPrice);
        }

        const allListings=await Listing.find(query);
        res.render("listings/index",{allListings, search, minPrice, maxPrice});
    }

module.exports.renderNewForm = (req, res) => {
    res.render("listings/new");
};

module.exports.createListing = async (req, res) => {
    let url=req.file.path;
    let filename= req.file.filename;
    const listing = new Listing(req.body.listing);
    listing.owner = req.user._id;
    listing.image={url,filename};
    await listing.save();
    req.flash("success", "New Listing created!");
    res.redirect("/listings");
};

module.exports.showListing = async (req, res) => {
    const listing = await Listing.findById(req.params.id)
        .populate("owner")
        .populate({
            path: "reviews",
            populate: { path: "author" }
        });

    if (!listing) {
        req.flash("error", "Listing doesn't exist!");
        return res.redirect("/listings");
    }

    // Get coordinates for map
    let coordinates = null;
    try {
        const { getCoordinates } = require("../utils/geocode");
        const locationString = `${listing.location}, ${listing.country}`;
        coordinates = await getCoordinates(locationString);
    } catch (error) {
        console.log("Geocoding failed:", error.message);
        // Use default coordinates if geocoding fails
        coordinates = { lat: 28.6139, lng: 77.2090 }; // Default to Delhi
    }

    res.render("listings/show", { listing, coordinates });
};

module.exports.renderEditForm = async (req, res) => {
    const listing = await Listing.findById(req.params.id);
    if (!listing) {
        req.flash("error", "Listing not found!");
        return res.redirect("/listings");
    }

    let originalImageUrl=listing.image.url;
    originalImageUrl= originalImageUrl.replace("/upload","/upload/h_300,w_250");
    res.render("listings/edit", { listing,originalImageUrl});
};

module.exports.updateListing = async (req, res) => {
    
    const listing = await Listing.findByIdAndUpdate(req.params.id, req.body.listing, { new: true });
    if(typeof req.file !=="undefined")
    {
    let url=req.file.path;
    let filename= req.file.filename;
    listing.image={url,filename};
    await listing.save();
    }

    req.flash("success", "Listing Updated!");
    res.redirect(`/listings/${listing._id}`);
};

module.exports.deleteListing = async (req, res) => {
    await Listing.findByIdAndDelete(req.params.id);
    req.flash("success", "Listing deleted!");
    res.redirect("/listings");
};
